<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>ngx-speculoos documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="./images/favicon.ico">
	   <link rel="stylesheet" href="./styles/style.css">
        <link rel="stylesheet" href="./styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="./" class="navbar-brand">ngx-speculoos documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content getting-started">
                   <div class="content-data">

<p><a href="https://circleci.com/gh/Ninja-Squad/ngx-speculoos"><img src="https://circleci.com/gh/Ninja-Squad/ngx-speculoos.svg?style=svg" alt="CircleCI" class="img-responsive"></a>
<a href="https://codecov.io/gh/Ninja-Squad/ngx-speculoos"><img src="https://codecov.io/gh/Ninja-Squad/ngx-speculoos/branch/master/graph/badge.svg" alt="Codecov" class="img-responsive"></a></p>
<h1>ngx-speculoos</h1>
<p>ngx-speculoos helps you write simpler, cleaner unit tests for your Angular components, based on the
<em>page object</em> pattern. It also provides utilities to make writing Angular unit tests easier.</p>
<p>The library simply wraps the standard Angular ComponentFixture, and you should thus be
able to understand and start using ngx-speculoos in just a few minutes if you already know
how to write Angular unit tests.</p>
<h2>Table of Contents</h2>
<ul>
<li><a href="#quick-presentation">Quick presentation</a><ul>
<li><a href="#why-should-you-care">Why should you care?</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#getting-started">Getting started</a></li>
</ul>
</li>
<li><a href="#features-in-details">Features in details</a><ul>
<li><a href="#componenttester">ComponentTester</a></li>
<li><a href="#automatic-change-detection">Automatic change detection</a></li>
<li><a href="#queries">Queries</a><ul>
<li><a href="#queries-for-elements">Queries for elements</a></li>
<li><a href="#css-and-type-selectors">CSS and Type selectors</a></li>
<li><a href="#queries-for-sub-components">Queries for sub components</a></li>
<li><a href="#queries-for-injection-tokens">Queries for injection tokens</a></li>
<li><a href="#queries-for-custom-testelement">Queries for custom TestElement</a></li>
<li><a href="#subqueries">Subqueries</a></li>
</ul>
</li>
<li><a href="#dispatching-events">Dispatching events</a></li>
<li><a href="#custom-jasmine-matchers">Custom Jasmine matchers</a></li>
<li><a href="#routing-helpers">Routing helpers</a><ul>
<li><a href="#activatedroute-stub">ActivatedRoute stub</a></li>
<li><a href="#routingtester">RoutingTester</a></li>
</ul>
</li>
<li><a href="#mocking-helper">Mocking helper</a></li>
<li><a href="#testing-with-a-host-component">Testing with a host component</a></li>
</ul>
</li>
<li><a href="#gotchas">Gotchas</a><ul>
<li><a href="#when-do-i-need-to-call-detectchanges">When do I need to call detectChanges()</a></li>
<li><a href="#can-i-use-the-testelement-methods-to-act-on-the-component-element-itself-rather-than-a-sub-element">Can I use the TestElement methods to act on the component element itself, rather than a sub-element?</a></li>
</ul>
</li>
<li><a href="#issues-questions">Issues, questions</a></li>
<li><a href="#complete-example">Complete example</a></li>
<li><a href="#upgrading-to-v13">Upgrading to v13</a></li>
</ul>
<h2>Quick presentation</h2>
<h3>Why should you care?</h3>
<p>If you&#39;ve ever written tests like the following:</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">it(&#39;should display French cities when selecting the country France&#39;, () =&gt; {
  const countrySelect = fixture.nativeElement.querySelector(&#39;#country&#39;); // countrySelect is of type any
  countrySelect.selectedIndex = 12; // what is at index 12?
  countrySelect.dispatchEvent(new Event(&#39;change&#39;)); // why do I need to do that?
  fixture.detectChanges();
  
  const city = fixture.nativeElement.querySelector(&#39;#city&#39;); // city is of type any
  expect(city).toBeTruthy();
  expect(city.options.length).toBe(3);
  expect(city.options[0].value).toBe(&#39;&#39;);
  expect(city.options[0].label).toBe(&#39;&#39;);
  expect(city.options[1].value).toBe(&#39;PARIS&#39;);
  expect(city.options[1].label).toBe(&#39;Paris&#39;);
  expect(city.options[2].value).toBe(&#39;LYON&#39;);
  expect(city.options[2].label).toBe(&#39;Lyon&#39;);
});

it(&#39;should hide cities when selecting the empty country option&#39;, () =&gt; {
  const countrySelect = fixture.nativeElement.querySelector(&#39;#country&#39;); // I did that previously. What about DRY?
  countrySelect.selectedIndex = 0;
  countrySelect.dispatchEvent(new Event(&#39;change&#39;)); // why do I need to do that?
  fixture.detectChanges(); // why do I need to do that?
  
  expect(fixture.nativeElement.querySelector(&#39;#city&#39;)).toBeFalsy(); // I did that previously. What about DRY?
});</code></pre></div><p>ngx-speculoos allows writing the above tests in a simpler, cleaner way:</p>
<ul>
<li>by using the page object pattern (which is optional, but recommended), you avoid repetitions.</li>
<li>by using wrappers around elements, dispatching events and triggering change detection is automatic.</li>
<li>by using wrappers around elements, you get useful additional methods to make tests easier to write and read.</li>
<li>by using custom matchers, you get even simpler expectations and more readable error messages</li>
<li>in any case you need them, you always have access to the fixture, the native elements, the debug elements, etc.</li>
</ul>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">class MyComponentTester extends ComponentTester&lt;MyComponent&gt; {
  constructor() {
    super(MyComponent);
  }
  
  get country() {
    return this.select(&#39;#country&#39;); // returns a TestSelect object, not any. Similar methods exist for inputs, buttons, etc.
  }
  
  get city() {
    return this.select(&#39;#city&#39;); // returns a TestSelect object, not any
  }
}

[...]

it(&#39;should display French cities when selecting the country France&#39;, () =&gt; {
  tester.country.selectLabel(&#39;France&#39;); // no dispatchEvent, no detectChanges needed
  
  expect(tester.city.optionValues).toEqual([&#39;&#39;, &#39;PARIS&#39;, &#39;LYON&#39;]);
  expect(tester.city.optionLabels).toEqual([&#39;&#39;, &#39;Paris&#39;, &#39;Lyon&#39;]);
});

it(&#39;should hide cities when selecting empty country option&#39;, () =&gt; {
  tester.country.selectIndex(0); // no repetition of the selector, no dispatchEvent, no detectChanges needed
  
  expect(tester.city).toBeFalsy(); // no repetition of the selector
});</code></pre></div><h3>Installation</h3>
<p>Using the CLI: <code>ng add ngx-speculoos</code></p>
<p>Using npm: <code>npm install --save-dev ngx-speculoos</code></p>
<p>Using yarn: <code>yarn add --dev ngx-speculoos</code></p>
<h3>Getting started</h3>
<ul>
<li>import ComponentTester, and other needed classes from ngx-speculoos</li>
<li>Create a <code>MyComponentTester</code> class (in your <code>my-component.spec.ts</code> file, typically) extending
<code>ComponentTester&lt;MyComponent&gt;</code>, as shown above.</li>
<li>Expose getters (or methods, if you prefer) returning the elements used in your tests, using
one of the ComponentTester methods (<code>element</code>, <code>elements</code>, <code>input</code>, <code>select</code>, <code>textarea</code>, <code>button</code>, etc.).
See the <a href="https://ngx-speculoos.ninja-squad.com/documentation/classes/ComponentTester.html">API documentation</a> for details</li>
<li>Write your tests, as shown above, benefiting from the additional methods on the TestXxx classes.</li>
<li>If needed, you can always get the fixture, componentInstance, debugElement, nativeElement, etc.
from the ComponentTester, and the nativeElement from each TestXxx wrapper.</li>
<li>If you like our custom matchers, add them in a <code>beforeEach</code> block as shown above, and enjoy.
You can also add them for all tests at once by adding the beforeEach block to the CLI-generated <code>test.ts</code> file.</li>
</ul>
<h2>Features in details</h2>
<h3>ComponentTester</h3>
<p>This is the entry point for most of the functionalities of ngx-speculoos. It wraps a <code>ComponentFixture</code>.
You can simply create one in your tests using</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">const tester = new ComponentTester(MyComponent);</code></pre></div><p>and then use it to query for sub elements, components, directives, etc. But we recommend adopting the
page object pattern, in order to make your test easier to write and read, and to avoid repeating the
same selectors over and over again.</p>
<p>You do that by writing a class that extends <code>ComponentTester</code>, and provides getters (or functions)
to query for elements, components, etc.</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">class MyComponentTester extends ComponentTester&lt;MyComponent&gt; {
  constructor() {
    super(MyComponent);
  }
  
  get country() {
    return this.select(&#39;#country&#39;); // returns a TestSelect object, not any. Similar methods exist for inputs, buttons, etc.
  }
  
  get city() {
    return this.select(&#39;#city&#39;); // returns a TestSelect object, not any
  }
}</code></pre></div><p>and then in your tests, or in your <code>beforeEach</code>, once you&#39;ve configured the testing module, you create
an instance of your component tester.</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">describe(&#39;My component&#39;, () =&gt; {
  let tester: MyComponentTester;
  
  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [MyComponent],
      ...
    });
    
    tester = new MyComponentTester();
    tester.change();
  });
  
  it(&#39;should ...&#39;, () =&gt; {
    
  });</code></pre></div><h3>Automatic change detection</h3>
<p>The future of Angular is zoneless. Without ZoneJS, components have to make sure to properly notify
Angular that they must be checked for changes, typically by updating signals.
Instead of imperatively triggering change detections in tests, it&#39;s thus a better idea to let
Angular decide if change detection must be run, in order to spot bugs where the component doesn&#39;t
properly handle its state changes.</p>
<p>This can be done by:</p>
<ul>
<li>adding a provider in the testing module to configure the fixtures to be in <em>automatic</em> mode</li>
<li>awaiting the component fixture stability when the test <em>thinks</em> that a change detection should
automatically happen.</li>
</ul>
<p>When the <code>provideAutomaticChangeDetection()</code> provider is added, the <code>ComponentTester</code> will run in
<em>automatic</em> mode. In this mode, calling <code>detectChanges()</code> throws an error, because you should always
let Angular decide if change detection is necessary.</p>
<p>Here&#39;s an example of a test that uses this technique:</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-ts">class AppComponentTester extends ComponentTester&lt;AppComponent&gt; {
  constructor() {
    super(AppComponent);
  }

  get incrementButton() {
    return this.button(&#39;button&#39;);
  }

  get count() {
    return this.element(&#39;#count&#39;);
  }
}

describe(&#39;AppComponent&#39;, () =&gt; {
  let tester: AppComponentTester;

  beforeEach(async () =&gt; {
    TestBed.configureTestingModule({
      providers: [
        provideComponentFixtureAutoDetection(),
        provideExperimentalZonelessChangeDetection() // if you already uses zoneless also add this provider
      ]
    });

    jasmine.addMatchers(speculoosMatchers);
    
    tester = new AppComponentTester();
    // a first call to change() is necessary to let Angular run its first change detection
    await tester.change();
  });

  it(&#39;should display the counter value and increment it&#39;, async () =&gt; {
    expect(tester.count).toHaveText(&#39;0&#39;);
    
    // this clicks the button and then lets Angular decide if a CD is necessary, and waits until
    // the DOM has been updated (or not)
    await tester.incrementButton.click();
    
    expect(tester.count).toHaveText(&#39;1&#39;);
  });
});</code></pre></div><p>In <em>automatic</em> mode, your test functions should be <code>async</code>, and each action you do with the elements
(<code>click()</code>, <code>dispatchEvent</code>, etc.) should be awaited.</p>
<h3>Queries</h3>
<h4>Queries for elements</h4>
<p>Most of the queries that ngx-speculoos supports are used to query for DOM elements. The queries, however,
don&#39;t actually returns native DOM elements, but wrappers around them, which are instances of <code>TestElement</code>.</p>
<p><code>TestElement</code> has more specialized subclasses: <code>TestHtmlElement</code>, <code>TestInput</code>, <code>TestSelect</code>, <code>TestTextarea</code>, <code>TestButton</code>.
Those subclasses offer helpful methods to get information or dispatch events to HTML elements, inputs, selects, etc.
Our custom matchers act on those <code>TestElement</code> objects.</p>
<p>You can <a href="#queries-for-custom-testelement">create your own subclasses of TestElement</a> and query for them, too.</p>
<p>A TestElement is a wrapper around an Angular <code>DebugElement</code>. So it can access the <code>DebugElement</code> and the
native DOM element that it wraps. It also has an instance of the <code>ComponentTester</code> which created it,
which itself wraps the Angular <code>ComponentFixture</code> and thus allows detecting changes automatically after
an element has been dispatched, for example.</p>
<h4>CSS and Type selectors</h4>
<p>The first kind of query uses CSS selectors. This is simply a wrapper around Angular&#39;s <code>DebugElement.query(By.css())</code>.
The second kind of query uses directive types. This is simply a wrapper around Angular&#39;s <code>DebugElement.query(By.directive())</code>.</p>
<p>Whatever the kind of selector you choose, the methods are the same though:</p>
<ul>
<li><code>element(selector)</code> to get the first element matching the selector</li>
<li><code>elements(selector)</code> to get an array of elements matching the selector</li>
</ul>
<p>Both of those methods will automatically return a <code>TestInput</code>, or a <code>TestSelect</code>, or any other <code>TestElement</code>
subclass that ngx-speculoos provides based on the actual type of element being matched. But if you know
in advance what the result of the query is, you can use more-specific methods, or their generic parameter.
Passing an HTML element name as selector also automatically returns the right type</p>
<ul>
<li><code>input(selector)</code> returns a <code>TestInput</code></li>
<li><code>textarea(selector)</code> returns a <code>TestTextarea</code></li>
<li><code>select(selector)</code> returns a <code>TestSelect</code></li>
<li><code>button(selector)</code> returns a <code>TestButton</code></li>
<li><code>element&lt;HtmlInputElement&gt;(selector)</code> returns a <code>TestInput</code></li>
<li><code>element&lt;HtmlDivElement&gt;(selector)</code> returns a <code>TestHtmlElement&lt;HtmlDivElement&gt;</code></li>
<li><code>elements&lt;HtmlButtonElement&gt;(selector)</code> returns an <code>Array&lt;TestButton&gt;</code></li>
<li><code>element(&#39;input&#39;)</code> returns a <code>TestInput</code></li>
</ul>
<h4>Queries for sub components</h4>
<p>It&#39;s often useful to get the component instance of a sub component, for example to inspect its state,
or to make one of its outputs emit something. You can do that using the <code>component</code> and <code>components</code>
methods:</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">get productIcon() {
  return this.component(ProductIconComponent); // returns a ProductIconComponent 
}

get reviewers() {
  return this.components(ReviewerComponent); // returns an Array&lt;ReviewerComponent&gt; 
}</code></pre></div><h4>Queries for injection tokens</h4>
<p>Querying using <code>element(DatepickerDirective)</code> will return you a <code>TestElement</code> on which the
<code>DatepickerDirective</code> has been applied.</p>
<p>If you need to get the <code>Datepicker</code> directive instance itself, then use the <code>token()</code> method
(or <code>tokens()</code> to get several of them)
which takes a selector (CSS or type) as first argument, and the token as second argument:</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">get datepicker() {
  return this.token(&#39;#birth-date&#39;, DatepickerDirective); // returns a DatepickerDirective instance
}</code></pre></div><h4>Queries for custom <code>TestElement</code></h4>
<p>We provide <code>TestInput</code>, <code>TestSelect</code>, etc. to easily inspect or interact with inputs and selects in our tests.
But what if you want the same kind of test abstraction for your own reusable components or directives, like
for example your <code>DatepickerDirective</code>.</p>
<p>You can create your own <code>TestElement</code> subclass for that. This subclass must have a constructor that
takes a <code>ComponentTester</code> as first argument, and a <code>DebugElement</code> as second argument.</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">class TestDatepicker extends TestHtmlElement&lt;HTMLElement&gt; {
  constructor(tester: ComponentTester&lt;unknown&gt;, debugElement: DebugElement) {
    super(tester, debugElement);
  }

  get inputField() {
    return this.input(&#39;input&#39;);
  }

  async setDate(year: number, month: number, day: number) {
    await this.inputField.fillWith(`${year}-${month}-${day}`);
  }

  async toggleDropdown() {
    await this.button(&#39;button&#39;).click();
  }
}</code></pre></div><p>Once you have created that class, you can use the <code>custom()</code> and <code>customs()</code> methods, using any selector,
to get instances of your custom `TestElement``</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">get birthDate() {
  return this.custom(&#39;#birth-date&#39;, TestDatepicker);
}</code></pre></div><b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">it(&#39;should not save if birth date is in the future&#39;, () =&gt;) {
  // ...
  tester.birthDate.setDate(2200, 1, 1);
  tester.save.click();
  expect(userService.create).not.toHaveBenCalled();
});</code></pre></div><p>or, in <em>automatic</em> mode</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">it(&#39;should not save if birth date is in the future&#39;), async () =&gt; {
  // ...
  await tester.birthDate.setDate(2200, 1, 1);
  await tester.save.click();
  expect(userService.create).not.toHaveBenCalled();
});</code></pre></div><h4>Subqueries</h4>
<p>A query is made from the root <code>ComponentTester</code>. But <code>TestElement</code> themselves also support queries.
So you can query for a parent <code>TestElement</code>, and then use it to perform subqueries:</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">get cardEditButton() {
  return this.element(&#39;.card&#39;).button(&#39;.edit&#39;);
}

get cardReviewerComponent() {
  return this.element(&#39;.card&#39;).component(ReviewerComponent);
}</code></pre></div><h3>Custom Jasmine matchers</h3>
<p>We provide custom matchers, that act on <code>TestElement</code> and on its more specific subclasses (<code>TestInput</code>, <code>TestSelect</code>, etc.).</p>
<p>The complete matcher list includes:</p>
<ul>
<li><code>toHaveClass(className: string)</code></li>
<li><code>toHaveValue(value: string)</code></li>
<li><code>toHaveText(textContent: string)</code></li>
<li><code>toHaveTrimmedText(textContent: string)</code></li>
<li><code>toContainText(textContent: string)</code></li>
<li><code>toBeChecked()</code></li>
<li><code>toHaveSelectedIndex(index: number)</code></li>
<li><code>toHaveSelectedValue(value: string)</code></li>
<li><code>toHaveSelectedLabel(label: string)</code></li>
<li><code>toBeVisible()</code></li>
</ul>
<p>These matchers must be installed in each test using them:</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">beforeEach(() =&gt; jasmine.addMatchers(speculoosMatchers));</code></pre></div><p>or in all tests, by adding the above line of code in the <code>test.ts</code> file.</p>
<h3>Dispatching events</h3>
<p><code>TestElement</code> provides two methods that allow dispatching events in a simple way.</p>
<ul>
<li><code>dispatchEvent(event: Event)</code></li>
<li><code>dispatchEventOfType(type: string)</code></li>
</ul>
<p>Going through these methods automatically calls <code>detectChanges()</code> on the <code>ComponentTester</code> after the event has been dispatched,
so you don&#39;t need to call that yourself.</p>
<p>The TestElement subclasses that we provide have more specific event dispatching methods.
For example</p>
<ul>
<li><code>TestHtmlElement.click()</code></li>
<li><code>TestInput.fillWith()</code> for text, password, number, etc.</li>
<li><code>TestInput.check()</code> for radios and checkboxes</li>
<li><code>TestInput.uncheck()</code> for checkboxes</li>
<li><code>TestTextarea.fillWith()</code></li>
<li><code>TestSelect.selectIndex()</code></li>
<li><code>TestSelect.selectValue()</code></li>
<li><code>TestSelect.selectLabel()</code></li>
</ul>
<p>Creating your own TestElement subclasses is a good way to provide such custom methods to interact
with your own reusable components in tests.</p>
<h3>Routing helpers</h3>
<h4>ActivatedRoute stub</h4>
<p>The library provides a stub for the <code>ActivatedRoute</code> class that you typically inject in your routed components.
It mimics the behavior of the actual <code>ActivatedRoute</code>, by having a snapshot and observables that emit when this
snapshot changes. And it also allows simulating navigations by imperatively changing the parameters, query parameters,
etc.</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">import { ActivatedRouteStub } from &#39;ngx-speculoos&#39;;

class RoutingComponentTester extends ComponentTester&lt;RoutingComponent&gt; {
  // ...
}

describe(&#39;routing component&#39;, () =&gt; {
  let route: ActivatedRouteStub;
  let tester: RoutingComponentTester;
  
  beforeEach(() =&gt; {
    route = stubRoute({
      params: { categoryId: &#39;pets&#39; }
    });
    
    TestBed.configureTestingModule({
      declarations: [RoutingComponent],
      providers: [
        { provide: ActivatedRoute, useValue: route }
      ]
    });
    
    tester = new RoutingComponentTester();
    tester.detectChanges();
  });
  
  it(&#39;should display all the products of the category&#39;, () =&gt; {
    // test based on the initial route state
  });

  it(&#39;should load other products when the category changes or when the query changes&#39;, () =&gt; {
    route.setParam(&#39;category&#39;, &#39;toys&#39;);
    tester.detectChanges();
    // ...

    route.setQueryParams({ &#39;max-price&#39;: &#39;30&#39;, target: &#39;children&#39; });
    tester.detectChanges();
    // ...
  });
});</code></pre></div><h4>RoutingTester</h4>
<p>An alternative approach to injecting a stub activated route consists in using the Angular <code>RouterTestingHarness</code>.
The library helps using it by providing a <code>RoutingTester</code>, which is a <code>ComponentTester</code> wrapping the
<code>RouterTestingHarness</code> in addition to wrapping its fixture, and additionally provides helper properties.</p>
<p>Here&#39;s an example usage of a component displaying the value of the query parameter <code>&#39;page&#39;</code> and allowing
to navigate to itself with a different value for that query parameter.</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">class PageComponentTester extends RoutingTester {
  constructor(harness: RouterTestingHarness) {
    super(harness);
  }

  get title() {
    return this.element(&#39;h1&#39;);
  }

  get link() {
    return this.element(&#39;a&#39;);
  }
}

describe(&#39;RoutingTester&#39;, () =&gt; {
  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      providers: [
        provideRouter([
          { path: &#39;list&#39;, component: PageComponent }
        ])
      ]
    });
  });

  it(&#39;should display the page of the query params&#39;, async () =&gt; {
    const tester = new PageComponentTester(await RouterTestingHarness.create(&#39;/list?page=42&#39;));

    expect(tester.title).toHaveText(&#39;Current page: 42&#39;);

    await tester.harness.navigateByUrl(&#39;/list?page=54&#39;);

    expect(tester.title).toHaveText(&#39;Current page: 54&#39;);
  });

  it(&#39;should navigate to the next page when clicking the link&#39;, async () =&gt; {
    const tester = new PageComponentTester(await RouterTestingHarness.create(&#39;/list?page=42&#39;));

    expect(tester.title).toHaveText(&#39;Current page: 42&#39;);

    tester.link.click();
    await tester.stable();

    expect(tester.urlTree.queryParamMap.get(&#39;page&#39;)).toBe(&#39;43&#39;);
    expect(tester.url).toBe(&#39;/list?page=43&#39;);
    expect(tester.title).toHaveText(&#39;Current page: 43&#39;);
  });
});
</code></pre></div><h3>Mocking helper</h3>
<p>Jasmine is quite verbose when creating mock objects in a typesafe way:</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">const productService = jasmine.createSpyObj&lt;ProductService&gt;(&#39;ProductService&#39;, [&#39;list&#39;, &#39;get&#39;, &#39;create&#39;, &#39;update&#39;]);</code></pre></div><p>Since most of what we mock (usually Angular services) are classes, we can actually do a bit of introspection
and create a mock that will automatically mock all the methods declared in the class. That&#39;s what our
<code>createMock()</code> function does. The above code can thus be reduced to:</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">const productService = createMock(ProductService);</code></pre></div><h3>Testing with a host component</h3>
<p>ngx-speculoos doesn&#39;t provide any specific support for testing with host components, but we do it
a lot, simply by creating a ComponentTester for the host component rather than the component under test:</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">&#64;Component({
  template: &#39;&lt;app-user [user]=&quot;user&quot; (smile)=&quot;smiled = true&quot;&gt;&lt;/app-user&gt;&#39;
})
class HostComponent {
  user: User = {
    id: &#39;u1&#39;,
    name: &#39;John&#39;
  };

  smiled = false;
}

class HostComponentTester extends ComponentTester&lt;HostComponent&gt; {
  constructor() {
    super(HostComponent);
  }

  get userComponent() {
    return this.component(UserComponent);
  }

  // ...
}</code></pre></div><p>Once you have that, you can access the host component using <code>componentInstance()</code>,
the component under test using <code>userComponent()</code>, and any element of the component under test
using the usual queries.</p>
<h2>Gotchas</h2>
<h3>When do I need to call <code>change</code> or <code>detectChanges()</code>?</h3>
<p>In <em>imperative</em> mode, any event dispatched through a <code>TestElement</code> automatically calls <code>detectChanges()</code> for you.
But you still need to call <code>change()</code> or <code>detectChanges()</code> by yourself in the other cases:</p>
<ul>
<li>to actually initialize your component. Sometimes, you want to configure some mocks before the <code>ngOnInit()</code>
method of your component is called. That&#39;s why creating a <code>ComponentTester</code> does not automatically call
<code>detectChanges()</code>. You need to do it yourself. The first call will cause the component lifecycle to start,
just as when using a <code>ComponentFixture</code> directly.</li>
<li>to force change detection once you&#39;ve changed the state of your component without dispatching an event:
by changing the state, or emitting an event through a subject, or triggering a navigation
from the <code>ActivatedRouteStub</code></li>
</ul>
<p>Note that, in <em>imperative</em> mode, <code>change()</code> calls <code>detectChanges()</code>. So you can call either one of the other
when you want to trigger a change detection.</p>
<p>In <em>automatic</em> mode, any event dispatched through a <code>TestElement</code> automatically calls <code>await change()</code> for you.
But you still need to call <code>await change()</code> by yourself in the same other cases as in the <em>imperative</em> mode:</p>
<ul>
<li>to actually initialize your component. </li>
<li>to force change detection once you&#39;ve changed the state of your component without dispatching an event.</li>
</ul>
<h3>Can I use the <code>TestElement</code> methods to act on the component element itself, rather than a sub-element?</h3>
<p>Yes. The <code>ComponentTester</code> has a <code>testElement</code> property, which is the <code>TestHtmlElement</code> wrapping the component&#39;s element.</p>
<h2>Issues, questions</h2>
<p>Please, provide feedback by filing issues, or by submitting pull requests, to the <a href="https://github.com/Ninja-Squad/ngx-speculoos">Github Project</a>.</p>
<h2>Complete example</h2>
<p>You can look at a minimal complete example in the <a href="https://github.com/Ninja-Squad/ngx-speculoos/tree/master/projects/demo/src/app">demo</a> project.</p>
<h2>Upgrading to v13</h2>
<p>Version 13 of <code>ngx-speculoos</code> introduces the <em>automatic</em> mode, consisting in using automatic change detection
instead of imperatively running change detections. See the <a href="#automatic-change-detection">Automatic change detection</a>
section above for details.</p>
<p>As a result, all the methods that used to call <code>detectChanges()</code> for you now return a <code>Promise</code> instead of returning
<code>void</code>. In <em>imperative</em> mode (the default), they are in fact synchronous and call <code>detectChanges()</code>, just as before.
In <em>automatic</em> mode however, they call <code>await change()</code> and should thus be awaited.</p>
<p>Your tests should generally keep compiling and running without changes. 
But if you created custom test elements which override methods that now return a promise, and return something 
other than <code>void</code>, for example:</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">class CustomInput extends TestInput {
  //...
  fillWith(s: string): CustomInput {
    super.fillWith(s);
    return this;
  }
}</code></pre></div><p>Then that won&#39;t compile anymore.</p>
<p>And in general, if you want your custom test element to be usable in both modes, all their method that explicitly
or indirectly called <code>detectChanges()</code> should now return a promise and explicitly of indirectly call <code>await change()</code>.
For example:</p>
<b>Example :</b><div><pre class="line-numbers"><code class="language-typescript">class CustomInput extends TestHtmlElement {
  //...
  async fillInput(s: string): Promise&lt;void&gt; {
    await this.element(&#39;input&#39;).fillWith(s);
    // ...
  }
  
  async clickButton(): Promise&lt;void&gt; {
    await this.element(&#39;button&#39;).click();
    // ...
  } 
  
  async changeState(): Promise&lt;void&gt; {
    this.component(Foo).doSomething();
    await this.change();
  }
}</code></pre></div>




















                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 0;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'getting-started';
            var COMPODOC_CURRENT_PAGE_URL = 'index.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="./js/libs/custom-elements.min.js"></script>
       <script src="./js/libs/lit-html.js"></script>

       <script src="./js/menu-wc.js" defer></script>
       <script nomodule src="./js/menu-wc_es5.js" defer></script>

       <script src="./js/libs/bootstrap-native.js"></script>

       <script src="./js/libs/es6-shim.min.js"></script>
       <script src="./js/libs/EventDispatcher.js"></script>
       <script src="./js/libs/promise.min.js"></script>

       <script src="./js/compodoc.js"></script>

       <script src="./js/tabs.js"></script>
       <script src="./js/menu.js"></script>
       <script src="./js/libs/clipboard.min.js"></script>
       <script src="./js/libs/prism.js"></script>
       <script src="./js/sourceCode.js"></script>
          <script src="./js/search/search.js"></script>
          <script src="./js/search/lunr.min.js"></script>
          <script src="./js/search/search-lunr.js"></script>
          <script src="./js/search/search_index.js"></script>
       <script src="./js/lazy-load-graphs.js"></script>


    </body>
</html>
